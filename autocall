#!/usr/bin/env php
<?php
    
    require_once 'vendor/autoload.php';
    
    use splitbrain\phpcli\CLI;
    use splitbrain\phpcli\Colors;
    use splitbrain\phpcli\Options;
    use splitbrain\phpcli\TableFormatter;
    use Symfony\Component\Yaml\Yaml;
    use React\EventLoop\Loop;
    
    class Minimal extends CLI
    {
        
        public array $companies = [];
        public int $trunks;
        public array $wait = ['from' => 1, 'to' => 1];
        public string $sequence = 'evenly';
        public string $trunk_mode = 'round';
        public int $queue_size = 3;
        public DateTime $start_time;
        //public string $pool_path = 'data/pool_test/';
        public string $pool_path_out = '/storage/usbdisk1/mikopbx/astspool/outgoing/';
        public string $pool_path_done = '/storage/usbdisk1/mikopbx/astspool/outgoing_done/';
        
        /**
         * register options and arguments
         * @param Options $options
         */
        protected function setup(Options $options): void
        {
            $options->setHelp('Скрипт автообзвона для Asterisk от Asko.Host');
            $options->registerCommand('run', 'Запустить обзвон');
            $options->registerCommand('list', 'Список компаний');
            $options->registerOption('trunks', 'Количество транков.', 't', 'count');
            $options->registerOption('sequence', 'Тип распределения по компаниям.', 's', 'own|evenly');
            $options->registerOption('wait',
                'Пауза между звонками в рамках кампании, в секундах. Можно задать случайный интервал 30-300', 'w',
                'string');
            $options->registerOption('queue_size', 'Максимальное количество звонков в процессе.', 'q', 'count');
            $options->registerOption('trunk_mode', 'Режим распределения транков (по кругу или случайно).', 'm',
                'round|rand');
        }
        
        /**
         * @param $name
         * @param $message
         */
        public function plog($name, $message): void
        {
            $time = date('Y-m-d H:i:s');
            $message = "$time: $message";
            file_put_contents($this->log_path($name), "$message\n", FILE_APPEND);
        }
    
        /**
         * implement your code
         * @param Options $options
         * @throws Exception
         */
        protected function main(Options $options): void
        {
            switch ($options->getCmd()) {
                case 'run':
                    $this->c_run($options);
                    break;
                case 'list':
                    $this->c_list();
                    $this->show_progress(false);
                    break;
                default:
                    $this->error('Ни одна известная команда не была вызвана, вместо этого мы показываем справку по умолчанию:');
                    echo $options->help();
                    exit;
            }
        }
        
        /**
         * @throws Exception
         */
        public function c_list(): void
        {
            $companies = glob(__DIR__ . "/data/companies/*", GLOB_ONLYDIR);
            
            foreach ($companies as $dir) {
                $name = basename($dir);
                
                if (!file_exists("$dir/number.list")) {
                    $error = "Нашел папку компании " . basename($dir) .
                             ", но в ней нет списка обзвона number.list";
                    throw new Exception($error);
                }
                
                $done_file = $this->splfile("$dir/finished.list");
                $file = $this->splfile("$dir/number.list");
                
                while ($phone = $file->current()) {
                    if ($done_file->current()) {
                        if ($phone !== $done_file->current()) {
                            throw new Exception("Нарушена последовательность списка номеров и завершенных");
                        }
                        $done_file->next();
                    }
                    $file->next();
                }
                
                $wait = $this->randWait();
                
                $this->plog($name, "Устанавливаем таймаут: $wait");
                
                $this->companies[ $name ] = [
                    'dir'      => $dir,
                    'log'      => date('Y-m-d_H:i:s') . ".log",
                    'spl'      => $file,
                    'spl_done' => $done_file,
                    'wait'     => $wait,                                        // Текущая пауза в секундах
                    'count'    => $file->key(),                                 // Всего номеров в компании
                    'queue'    => [],                                           // В процессе
                    'length'   => 0,                                            // Кол-во в процессе
                    'done'     => $done_file->key(),                            // Завершено
                    'template' => [],
                ];
                
                $file->seek($done_file->key());
                
                $trunks_path = "$dir/trunks.list";
                
                if (!file_exists($trunks_path)) {
                    throw new Exception("Для компании $name не нашел список транков или он пуст!");
                }
                
                $trunks = file($trunks_path, FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES);
                
                if ($trunks === false) {
                    throw new Exception("Не смог прочитать файл со списком транков $trunks_path");
                }
                
                $this->companies[ $name ][ 'trunks' ] = $trunks;
                
                $cafile_path = "$dir/call_file.tpl";
                
                if (!file_exists($cafile_path)) {
                    throw new Exception("Для компании $name не нашел шаблон Call файла!");
                }
                
                $cafile = file_get_contents($cafile_path);
                $this->companies[ $name ][ 'template' ][ 'raw' ] = $cafile;
                
                $ini = Yaml::parse($cafile);
                
                $this->companies[ $name ][ 'template' ][ 'direction' ] = $ini[ 'Context' ] . ' [' . $ini[ 'Extension' ] . ']';
            }
        }
        
        /**
         * @param $path
         * @return SplFileObject
         */
        public function splfile($path): SplFileObject
        {
            $file = new SplFileObject($path, 'a+');
            $file->setFlags(SplFileObject::READ_AHEAD | SplFileObject::SKIP_EMPTY | SplFileObject::DROP_NEW_LINE);
            return $file;
        }
        
        public function show_progress($is_update = true): void
        {
            if ($is_update) {
                system('clear');
            }
            
            if ($is_update) {
                fwrite(STDOUT, PHP_EOL);
                $this->info("Кол-во рабочих транков или параллельных каналов: " . $this->trunks);
                $this->info("Способ распределения очереди между кампаниями: " . $this->sequence);
                $wait = implode('-', $this->wait);
                $this->info("Интервал в секундах между звонками в кампаниях: $wait");
                $this->info("Максимальное кол-во звонков в процессе на кампанию: " . $this->queue_size);
                $this->info("Режим распределения транков: " . $this->trunk_mode);
                fwrite(STDOUT, PHP_EOL);
                $elapsed = $this->start_time->diff(new DateTime)->format('%h:%i:%s');
                $this->alert("Прошло времени: $elapsed");
            }
            
            fwrite(STDOUT, PHP_EOL);
            
            $tf = new TableFormatter($this->colors);
            $tf->setBorder(' | '); // nice border between columns
            
            $tf->setMaxWidth(120);
            
            // show a header
            echo $tf->format(
                ['*', '20%', '14%', '14%', '14%', '6%'],
                ['Список компаний', 'Направление', 'Всего', 'Завершено', 'Осталось', '']
            );
            
            // a line across the whole width
            echo str_pad('', $tf->getMaxWidth(), '-') . "\n";
            
            ksort($this->companies);
            
            foreach ($this->companies as $name => $company) {
                $remain = $company[ 'count' ] - $company[ 'done' ];
                $progress = round($company[ 'done' ] * 100 / $company[ 'count' ]);
                
                $direction = $company[ 'template' ][ 'direction' ];
                
                echo $tf->format(
                    ['*', '20%', '14%', '14%', '14%', '6%'],
                    [$name, $direction, $company[ 'count' ], $company[ 'done' ], $remain, "$progress%"],
                    [Colors::C_CYAN, Colors::C_WHITE, Colors::C_WHITE, Colors::C_GREEN, Colors::C_RED, Colors::C_YELLOW]
                );
                
                // todo:: Убрать контроль окончания кампании из вывода прогресса
                if ($is_update && $remain === 0) {
                    // Отмечаем что очередь вызовов закончена
                    $this->companies[ $name ][ 'is_over' ] = 1;
                    // Отключаем обработку очереди вызовов
                    Loop::cancelTimer($this->companies[ $name ][ 'timer_queue' ]);
                }
            }
        }
        
        /**
         * Извлекаем транк.
         * В зависимости от режиме либо по кругу либо случайный
         * @param        $name
         * @param string $mode
         * @return mixed
         */
        public function get_trunk($name, string $mode = 'round')
        {
            if ($mode === 'round') {
                $trunk = array_shift($this->companies[ $name ][ 'trunks' ]);
                $this->companies[ $name ][ 'trunks' ][] = $trunk;
                return $trunk;
            }
            
            if ($mode === 'rand') {
                $rand_key = array_rand($this->companies[ $name ][ 'trunks' ]);
                return $this->companies[ $name ][ 'trunks' ][ $rand_key ];
            }
        }
        
        public function temp_call($name, $phone): string
        {
            return "data/temporary/{$name}{$phone}.call";
        }
        
        public function pool_call($name, $phone): string
        {
            return $this->pool_path_out . $name . $phone . ".call";
        }
        
        public function pool_call_done($name, $phone): string
        {
            return $this->pool_path_done . $name . $phone . ".call";
        }
        
        /**
         * @throws Exception
         */
        public function asterisk_cli_passthru($command): string
        {
            ob_start();
            passthru("asterisk -rx '$command'", $b);
            $out = ob_get_clean();
            
            if ($b !== 0) {
                throw new Exception($out);
            }
            
            return $out;
        }
        
        /**
         * @throws Exception
         */
        public function log_path($name): string
        {
            $filename = $this->companies[ $name ][ 'log' ];
            $log_dir = $this->companies[ $name ][ 'dir' ] . "/logs";
            if (!file_exists($log_dir) && !mkdir($log_dir, 0755, true) && !is_dir($log_dir)) {
                throw new Exception(sprintf('Директория "%s" не может быть создана', $log_dir));
            }
            return "$log_dir/$filename";
        }
        
        // Смотрим какие звонки ушли из очереди
        
        /**
         * @throws Exception
         */
        public function harvest_info_pool(): void
        {
            foreach ($this->companies as $name => $company) {
                foreach ($company[ 'queue' ] as $phone => $create) {
                    if (!file_exists($this->pool_call($name, $phone)) && file_exists($this->pool_call_done($name,
                            $phone))) {
                        unset($this->companies[ $name ][ 'queue' ][ $phone ]);
                        $this->companies[ $name ][ 'length' ]--;
                        $this->companies[ $name ][ 'done' ]++;
                        
                        $message = "Звонок на $phone завершен. Активных звонков: " .
                                   $this->companies[ $name ][ 'length' ];
                        
                        $this->plog($name, $message);
                        
                        // Удалим
                        if (!unlink($this->pool_call_done($name, $phone))) {
                            throw new Exception("Не смогу удалить " . $this->pool_call_done($name, $phone));
                        }
                    }
                }
            }
        }
        
        public function randWait(): int
        {
            return random_int($this->wait[ 'from' ], $this->wait[ 'to' ]);
        }
        
        /**
         * @param Options $options
         */
        public function wait_init(Options $options): void
        {
            $wait = $options->getOpt('wait');
            
            if ($wait !== false) {
                $interval = explode('-', $wait);
                
                if (count($interval) === 0) {
                    $this->error("Неверный формат интервала между звонками.");
                    echo $options->help();
                    Loop::stop();
                    exit();
                }
                
                foreach ($interval as $opt) {
                    if (!is_numeric($opt)) {
                        $this->error("Неверный формат интервала между звонками.");
                        echo $options->help();
                        Loop::stop();
                        exit();
                    }
                }
            }
            
            $this->wait[ 'from' ] = $interval[ 0 ] ?? $this->wait[ 'from' ];
            $this->wait[ 'to' ] = $interval[ 1 ] ?? $this->wait[ 'from' ];
        }
        
        public function c_run(Options $options): void
        {
            $sequence = $options->getOpt('sequence');
            $this->sequence = $sequence ?: $this->sequence;
            
            $sequence = $options->getOpt('trunk_mode');
            $this->trunk_mode = $sequence ?: $this->trunk_mode;
            
            $this->wait_init($options);
            
            $queue_size = $options->getOpt('queue_size');
            $this->queue_size = $queue_size ?: $this->queue_size;
            
            $this->start_time = new DateTime();
            
            $this->c_list();
            
            $trunks = $options->getOpt('trunks');
            $this->trunks = $trunks ?: count($this->companies);
            
            foreach ($this->companies as $name => $company) {
                $this->plog($name, "Добавил таймер обработки очереди");
                
                $this->companies[ $name ][ 'timer_queue' ] = Loop::addPeriodicTimer(1, function () use ($name)
                {
                    try {
                        // Отсортируем компании по количеству активных звонков (в очереди)
                        uasort($this->companies, static function ($a, $b)
                        {
                            return ($a[ 'length' ] - $b[ 'length' ]);
                        });
                        
                        // если включена опция evenly и у текущей компании не меньше всего звонков в очереди
                        if ($this->sequence === 'evenly' && array_key_first($this->companies) !== $name) {
                            return;
                        }
                        
                        $last_call = $this->companies[ $name ][ 'last_call' ] ?? date('Y-m-d H:i:s');
                        $diff_sec = abs(strtotime($last_call) - time());
                        
                        $company = $this->companies[ $name ];
                        
                        // Если с момента последнего прошло время либо еще не было ни одного звонка
                        if ($diff_sec >= $company[ 'wait' ] || empty($company[ 'last_call' ])) {
                            $this->add_queue($name);
                        }
                    } catch (Throwable $e) {
                        $this->error($e->getMessage());
                        $this->plog($name, "Error: " . $e->getMessage());
                        Loop::stop();
                    }
                });
            }
            
            // Запускаем обработку
            Loop::addPeriodicTimer(0.9, function ()
            {
                $this->harvest_info_pool();
                $this->show_progress();
                
                $overs = array_sum(array_column($this->companies, "is_over"));
                
                if ($overs === count($this->companies)) {
                    fwrite(STDOUT, PHP_EOL);
                    $this->success('Обзвон законен!');
                    Loop::stop();
                }
            });
            
            Loop::run();
        }
        
        /**
         * @throws Exception
         */
        public function add_queue($name): void
        {
            if (!$phone = $this->companies[ $name ][ 'spl' ]->current()) {
                return;
            }
            
            if ($this->sequence === 'own') {
                $free_calls = $this->queue_size - $this->companies[ $name ][ "length" ];
            } else {
                $length = array_sum(array_column($this->companies, "length"));
                $free_calls = $this->trunks - $length;
            }
            
            $phone = trim($phone);
            
            // Если есть окно, то добавляем еще звонок
            if ($free_calls && !file_exists($this->pool_call($name, $phone))) {
                
                $trunk = $this->get_trunk($name);
                
                $out = $this->asterisk_cli_passthru('core show channels concise');
                
                $_trunk = explode('-', $trunk);
                $_trunk = implode('-', [$_trunk[0], $_trunk[1]]);

                if (strpos($out, $_trunk) !== false) {
                    $this->plog($name, "Транк $trunk еще занят, пропустим добавление звонка.");
                    return;
                }
                
                $wait = $this->randWait();
                $message = "Добавляем звонок [$phone] в очередь";
                $this->plog($name, $message);
                $message = "Устанавливаем таймаут до следующего звонка: $wait";
                $this->plog($name, $message);
                
                $this->companies[ $name ][ 'wait' ] = $wait;  // Задаем задержку до нового звонка
                
                $cafile = str_replace("__number__", $phone, $this->companies[ $name ][ 'template' ][ 'raw' ]);
                $cafile = str_replace("__trunk__", $trunk, $cafile);
                
                $path_temp = $this->temp_call($name, $phone);
                if (file_put_contents($path_temp, $cafile) === false) {
                    throw new Exception("Не смог сохранить временный файл по пути $path_temp");
                }
                
                $path_pool = $this->pool_call($name, $phone);
                if (rename($path_temp, $path_pool) === false) {
                    throw new Exception("Не смог переместить временный файл по пути $path_pool");
                }
                
                $time = date('Y-m-d H:i:s');
                
                $this->companies[ $name ][ 'last_call' ] = $time; // Запоминаем время создания звонка
                $this->companies[ $name ][ 'queue' ][ $phone ] = $time;
                $this->companies[ $name ][ 'length' ]++;
                
                $this->companies[ $name ][ 'spl_done' ]->fwrite($phone . PHP_EOL);
            }
        }
        
    }
    
    // execute it
    $cli = new Minimal();
    $cli->run();