#!/usr/bin/env php
<?php
    
    require_once 'vendor/autoload.php';
    
    use splitbrain\phpcli\CLI;
    use splitbrain\phpcli\Colors;
    use splitbrain\phpcli\Options;
    use splitbrain\phpcli\TableFormatter;
    use Symfony\Component\Yaml\Yaml;
    use React\EventLoop\Loop;
    
    class Minimal extends CLI
    {
        
        public array $companies = [];
        public int $trunks;
        public int $wait = 1;
        public string $sequence = 'evenly';
        public int $queue_size = 3;
        public string $template_path = 'data/templates/';
        public DateTime $start_time;
        //public $pool_path = 'data/pool';
        public string $pool_path = '/storage/usbdisk1/mikopbx/astspool/outgoing/';
        public string $temp_path = 'data/temp/';
        public string $done_path = 'data/companies/done/';
        
        /**
         * register options and arguments
         * @param Options $options
         */
        protected function setup(Options $options): void
        {
            $options->setHelp('Скрипт автообзвона для MikoPBX от Asko.Host');
            $options->registerCommand('run', 'Запустить обзвон');
            $options->registerCommand('list', 'Список компаний');
            $options->registerOption('trunks', 'Количество транков.', 't', 'count');
            $options->registerOption('sequence', 'Тип распределения по компаниям.', 's', 'count');
            $options->registerOption('wait', 'Пауза между звонками в рамках кампании.', 'w', 'own|evenly');
            $options->registerOption('queue_size', 'Максимальное количество звонков в процессе.', 'q', 'count');
        }
        
        /**
         * implement your code
         * @param Options $options
         */
        protected function main(Options $options): void
        {
            switch ($options->getCmd()) {
                case 'run':
                    $this->c_run($options);
                    break;
                case 'list':
                    $this->c_list();
                    break;
                default:
                    $this->error('Ни одна известная команда не была вызвана, вместо этого мы показываем справку по умолчанию:');
                    echo $options->help();
                    exit;
            }
        }
        
        public function c_list(): void
        {
            $companies = glob("data/companies/list/*.txt");
            
            foreach ($companies as $company) {
                $file = new SplFileObject($company, 'r');
                $file->setFlags(SplFileObject::SKIP_EMPTY | SplFileObject::DROP_NEW_LINE);
                
                while ($file->current()) {
                    $file->next();
                }
                
                $count = $file->key();
                $name = pathinfo($company, PATHINFO_FILENAME);
                $basename = pathinfo($company, PATHINFO_BASENAME);
                
                $this->companies[ $name ] = [
                    'spl'    => $file,
                    'count'  => $count,    // Всего номеров в компании
                    'queue'  => [],        // В процессе
                    'length' => 0,         // Кол-во в процессе
                    'done'   => 0          // Завершено
                ];
                
                if (file_exists($this->template_call($name))) {
                    $this->companies[ $name ][ 'template' ] = file_get_contents($this->template_call($name));

                    if (file_exists($this->done_path($basename))) {
                        $done_file = new SplFileObject($this->done_path($basename), 'r');
                        $done_file->setFlags(SplFileObject::SKIP_EMPTY | SplFileObject::DROP_NEW_LINE);
                        while ($done_file->current()) {
                            $done_file->next();
                        }
                        $diff = $done_file->key();
                        $this->companies[ $name ][ 'done' ] = $diff;
                        $file->seek($diff);
                    } else {
                        $file->rewind();
                    }
                } else {
                    $this->error("Для компании $name не нашел шаблон Call файла!");
                }
                
                unset($file, $done_file);
            }
  
        }
        
        public function show_progress(): void
        {
            system('clear');
            
            $this->info("Кол-во рабочих транков или параллельных каналов: " . $this->trunks);
            $this->info("Способ распределения очереди между кампаниями: " . $this->sequence);
            $this->info("Интервал в секундах между звонками в кампании: " . $this->wait);
            $this->info("Максимальное количество звонков в процессе: " . $this->queue_size);
            
            fwrite(STDOUT, PHP_EOL);
            
            $elapsed = $this->start_time->diff(new DateTime)->format('%h:%i:%s');
            $this->alert("Прошло времени: $elapsed");
            
            fwrite(STDOUT, PHP_EOL);
            
            $tf = new TableFormatter($this->colors);
            $tf->setBorder(' | '); // nice border between columns
            
            $tf->setMaxWidth(120);
            
            // show a header
            echo $tf->format(
                ['*', '20%', '14%', '14%', '14%', '14%', '6%'],
                ['Список компаний', 'Направление', 'Всего', 'В процессе', 'Завершено', 'Осталось', '']
            );
            
            // a line across the whole width
            echo str_pad('', $tf->getMaxWidth(), '-') . "\n";
            
            ksort($this->companies);
            
            foreach ($this->companies as $name => $company) {
                $remain = $company[ 'count' ] - $company[ 'done' ];
                $progress = round($company[ 'done' ] * 100 / $company[ 'count' ]);
                
                $ini = Yaml::parse($company[ 'template' ]);
                $direction = $ini[ 'Context' ] . ' [' . $ini[ 'Extension' ] . ']';
                
                echo $tf->format(
                    ['*', '20%', '14%', '14%', '14%', '14%', '6%'],
                    [$name, $direction, $company[ 'count' ], $company[ 'length' ], $company[ 'done' ], $remain, "$progress%"],
                    [Colors::C_CYAN, Colors::C_WHITE, Colors::C_WHITE, Colors::C_PURPLE, Colors::C_GREEN, Colors::C_RED, Colors::C_YELLOW]
                );
                
                if ($remain === 0) {
                    $this->companies[ $name ][ 'is_over' ] = 1;
                }
            }
        }
        
        public function template_call($name): string
        {
            return $this->template_path . $name . ".call";
        }
        
        public function temp_call($name, $phone): string
        {
            return $this->temp_path . $name . $phone . ".call";
        }
        
        public function pool_call($name, $phone): string
        {
            return $this->pool_path . $name . $phone . ".call";
        }
        
        public function done_path($filename): string
        {
            return $this->done_path . $filename;
        }
        
        // Смотрим какие звонки ушли из очереди
        public function harvest_info_pool(): void
        {
            foreach ($this->companies as $name => $company) {
                foreach ($company[ 'queue' ] as $phone => $create) {
                    if (!file_exists($this->pool_call($name, $phone))) {
                        unset($this->companies[ $name ][ 'queue' ][ $phone ]);
                        $this->companies[ $name ][ 'length' ]--;
                        $this->companies[ $name ][ 'done' ]++;
                    }
                }
            }
        }
        
        public function c_run(Options $options): void
        {
            
            $sequence = $options->getOpt('sequence');
            $this->sequence = $sequence ?: $this->sequence;
            
            $wait = $options->getOpt('wait');
            $this->wait = $wait ?: $this->wait;
    
            $queue_size = $options->getOpt('queue_size');
            $this->queue_size = $queue_size ?: $this->queue_size;
            
            $this->start_time = new DateTime();
    
            $this->c_list();
    
            $trunks = $options->getOpt('trunks');
            $this->trunks = $trunks ?: count($this->companies);
            
            foreach ($this->companies as $name => $company) {
                $this->companies[ $name ][ 'timer_queue' ] = Loop::addPeriodicTimer(1, function () use ($name)
                {
                    try {
                        // Отсортируем компании по количеству активных звонков (в очереди)
                        uasort($this->companies, static function ($a, $b)
                        {
                            return ($a[ 'length' ] - $b[ 'length' ]);
                        });
                        
                        // если включена опция evenly и у текущей компании не меньше всего звонков в очереди
                        if ($this->sequence === 'evenly' && array_key_first($this->companies) !== $name) {
                            return;
                        }
                        
                        // Находим в очереди самый последний звонок
                        uasort($this->companies[ $name ][ 'queue' ], static function ($a, $b)
                        {
                            return strtotime($a) - strtotime($b);
                        });
                        
                        $last_call = end($this->companies[ $name ][ 'queue' ]);
                        $last_call = $last_call ?: date ('Y-m-d H:i:s');
                        
                        $diff_sec = abs(strtotime($last_call) - time());

                        // Если с момента последнего прошло время
                        if ($diff_sec >= $this->wait || $this->companies[ $name ][ 'length' ] === 0) {
                            $this->add_queue($name);
                        }
                    } catch (Throwable $e) {
                        $this->error($e->getMessage());
                        
                        Loop::stop();
                    }
                });
            }
            
            // Запускаем обработку каждую секунду
            Loop::addPeriodicTimer(1, function ()
            {
                $this->show_progress();
                $this->harvest_info_pool();
                
                $overs = array_sum(array_column($this->companies, "is_over"));
                
                if ($overs === count($this->companies)) {
                    fwrite(STDOUT, PHP_EOL);
                    $this->success('Обзвон законен!');
                    Loop::stop();
                }
            });
            
            Loop::run();
        }
        
        public function add_queue($name): void
        {

            if (!$phone = $this->companies[ $name ][ 'spl' ]->current()) {
                return;
            }
            
            if($this->sequence === 'own') {
                $free_calls = $this->queue_size - $this->companies[ $name ]["length"];
            } else {
                $length = array_sum(array_column($this->companies, "length"));
                $free_calls = $this->trunks - $length;
            }

            $phone = trim($phone);
            
            // Если есть окно, то добавляем еще звонок
            if ($free_calls && !file_exists($this->pool_call($name, $phone))) {
                
                $call_file = str_replace("__number__", $phone, $this->companies[ $name ][ 'template' ]);

                file_put_contents($this->temp_call($name, $phone), $call_file);
                rename($this->temp_call($name, $phone), $this->pool_call($name, $phone));
                
                $this->companies[ $name ][ 'queue' ][ $phone ] = date('Y-m-d H:i:s');
                $this->companies[ $name ][ 'length' ]++;
                
                file_put_contents($this->done_path("$name.txt"), "$phone\n", FILE_APPEND | LOCK_EX);
    
                $this->companies[ $name ][ 'spl' ]->next();
            }
        }
        
    }
    
    // execute it
    $cli = new Minimal();
    $cli->run();